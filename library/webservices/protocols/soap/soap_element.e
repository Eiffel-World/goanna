indexing
	description: "Abstract objects that represent general SOAP element."
	project: "Project Goanna <http://sourceforge.net/projects/goanna>"
	library: "SOAP"
	date: "$Date$"
	revision: "$Revision$"
	author: "Glenn Maughan <glennmaughan@optushome.com.au>"
	copyright: "Copyright (c) 2001 Glenn Maughan and others"
	license: "Eiffel Forum Freeware License v1 (see forum.txt)."

deferred class

	SOAP_ELEMENT

inherit
	
	SOAP_CONSTANTS
		export
			{NONE} all
		end
	
	SOAP_FAULTS
		export
			{NONE} all
		end
		
	XML_SCHEMA_CONSTANTS
		export
			{NONE} all
		end
		
feature -- Initialization
	
	unmarshall (node: XM_ELEMENT) is
			-- Initialise SOAP envelope from XML node.
		require
			node_exists: node /= Void
		deferred			
		end

feature -- Access

	encoding_style: UC_STRING
			-- Space separated encoding style URIs scoped within this element.

feature -- Status report

	unmarshall_ok: BOOLEAN
			-- Was unmarshalling performed successfully?

	unmarshall_fault: SOAP_FAULT
			-- Fault generated by unmarshalling error. Available if not
			-- 'unmarshall_ok'.

feature -- Status setting

	set_encoding_style (new_encoding_style: like encoding_style) is
			-- Set 'encoding_style' to 'new_encoding_style'
		require
			new_encoding_style_exists: new_encoding_style /= Void
		do
			encoding_style := new_encoding_style
		end

feature -- Mashalling

	marshall: STRING is
			-- Serialize this envelope to XML format
		deferred	
		end

feature {NONE, SOAP_NODE_FORMATTER} -- Implementation

	encoding_style_attribute: STRING is
			-- Create encoding style attribute for insertion in marshall strings.
			-- Created string is prefixed with a single space.
		require
			encoding_style_set: encoding_style /= Void
		do
			create Result.make (40)
			Result.append_string (" env:encodingStyle=%"")
			Result.append (encoding_style.out)
			Result.append_string ("%"")
		end
		
feature {NONE} -- Implementation

	get_named_element (parent: XM_ELEMENT; name, namespace: UC_STRING): XM_ELEMENT is
			-- Search for and return first element with 'name' and 'namespace'. Return
			-- Void if not found.
		require
			parent_exists: parent /= Void
			name_exists: name /= Void
		local
			child_node_cursor: DS_BILINEAR_CURSOR [XM_NODE]
			child: XM_ELEMENT
			found: BOOLEAN
		do
			if not parent.is_empty then
				from
					child_node_cursor := parent.new_cursor
					child_node_cursor.start
				until		
					child_node_cursor.off or found
				loop
					child ?= child_node_cursor.item
					if child /= Void then
						if child.name.is_equal (name) and then child.has_namespace 
							and then child.namespace.is_equal (namespace) then
							Result := child
							found := True
						end
					end
					child_node_cursor.forth			
				end
			end
		end
		
	check_qualified_name (elem: XM_NAMED_NODE; name, namespace: UC_STRING): BOOLEAN is
			-- Does 'elem' have the specified 'name' and 'namespace'?
		require
			node_exists: elem /= Void
			name_exists: name /= Void
			namespace_exists: namespace /= Void
		do
			Result := elem.name.is_equal (name) 
				and then elem.has_namespace
				and then elem.namespace.is_equal (namespace)
		end
		
	unmarshall_encoding_style_attribute (node: XM_ELEMENT) is
			-- Search for optional encodingStyle attribute, unmarshall and set
			-- encoding style if found. Notify of unmarshalling error by setting
			-- 'unmarshall_ok'.
			--| encoding style attribute is explicitly encoded as an XMLSchema anyURI.
		require
			node_exists: node /= Void
		local
			new_value: SOAP_VALUE
			str: UC_STRING
			attr: XM_ATTRIBUTE
		do
			if node.has_attribute_by_name (Encoding_style_attr) then
				attr := node.attribute_by_name (Encoding_style_attr)
				if attr.has_namespace and attr.namespace.is_equal (Ns_name_env) then
					value_factory.unmarshall_value (attr.value, Ns_name_xs, Xsd_anyuri)
					if not value_factory.unmarshall_ok then
						unmarshall_ok := False
						unmarshall_fault := value_factory.unmarshall_fault
					else
						str ?= value_factory.last_value.as_object
						set_encoding_style (str)
					end	
				else
					unmarshall_ok := False
					unmarshall_fault := create_fault (Client_fault_code, Malformed_encoding_style_fault_code)
				end		
			end
		end
		
invariant

	unmarshall_error: not unmarshall_ok implies unmarshall_fault /= Void
	marshall_ok_no_fault: unmarshall_ok implies unmarshall_fault = Void
	
end -- class SOAP_ELEMENT
