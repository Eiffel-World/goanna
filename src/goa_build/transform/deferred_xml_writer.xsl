<?xml version="1.0"?> 
<!--
     	description: "Create a deferred Eiffel Class that represents an XML document conforming with a
  		      Fragment of a Relax NG Schema intended for inclusion in another document."
	author: "Neal L Lester <neal@3dsafety.com>"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "Copyright (c) 2004 Neal L Lester"
	license:   "Eiffel Forum License V2.0 (http://www.opensource.org/licenses/ver2_eiffel.php)"

DESCRIPTION

Please see the file validating_xml_writer.xsl for a description
of the framework which includes this file.

deferred_xml_writer.xsl creates a deferred class that represents a
schema fragment intended for inclusion in another schema.  This allows
eiffel to see documents containing the included schema as a distinct
type.

-->

<xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
  xmlns:rng="http://relaxng.org/ns/structure/1.0"
  exclude-result-prefixes="rng">

	<xsl:include href="common.xsl" />
	<xsl:key name="attributes" match="//rng:attribute" use="@name" />
	<xsl:key name="elements" match="//rng:element" use="../@name" />
	<xsl:key name="refs" match="//rng:ref" use="@name" />

<xsl:template match="/rng:grammar">
	<xsl:variable name="name" select="@name"/>
 	<xsl:variable name="element" select="key ('elements', $name)" />
 	<xsl:variable name="last_ref" select="$element/descendant::rng:ref[position () = last()]" />
 	<xsl:variable name="includes_elements" select="$element/descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name)]" />
 	<xsl:variable name="open_ended" select="$last_ref[ancestor::rng:oneOrMore or ancestor::rng:zeroOrMore]" />
indexing

	description: "An XML Document conforming with the xmlns:<xsl:value-of select="$prefix_lower"/> schema"
	author: "<xsl:value-of select="$author" />"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "<xsl:value-of select="$copyright" />"
	license: "<xsl:value-of select="$license" />"

-- DO NOT EDIT THIS FILE
-- This file was generated by deferred_xml_writer.xsl
-- Any changes made to this file will be overwritten the 
-- next time the XSL Transformation is run.

deferred class
	<xsl:value-of select="$prefix_upper" />_XML_DOCUMENT
	
inherit
	GOA_XML_DOCUMENT
	<xsl:value-of select="$prefix_upper" />_ATTRIBUTE_VALUES
	<xsl:apply-templates select="//rng:include" />	
	
feature -- Adding Elements

<xsl:apply-templates select="//rng:element" mode="element_features">
	<xsl:with-param name="include_dbc" select="'yes'" />
	<xsl:with-param name="is_deferred" select="'yes'" />
</xsl:apply-templates>

feature -- Element Tags

	<xsl:for-each select="//rng:element" >
		<xsl:text>&#x9;</xsl:text><xsl:apply-templates select="." mode="element_tag_constant" />
		<xsl:text>: STRING is &#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;deferred&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;end&#xA;&#xA;</xsl:text>
	</xsl:for-each>	
 	
feature -- Attribute Names

	<xsl:for-each select="//rng:attribute" >
		<xsl:variable name="fixed_tag" select="translate(@name, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ:-', 'abcdefghijklmnopqrstuvwxyz__')" />
		<xsl:text>&#x9;</xsl:text><xsl:apply-templates select="." mode="attribute_name_constant" />
		<xsl:text>: STRING is&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;deferred&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;end&#xA;&#xA;</xsl:text>
	</xsl:for-each>	

feature -- Codes

	<xsl:for-each select="//rng:attribute" >
		<xsl:text>&#x9;</xsl:text><xsl:apply-templates select="." mode="attribute_code" /><xsl:text>: INTEGER is&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;deferred&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;end&#xA;&#xA;</xsl:text>
	</xsl:for-each>
		
	<xsl:for-each select="//rng:element" >
		<xsl:text>&#x9;</xsl:text><xsl:apply-templates select="." mode="element_code" /><xsl:text>: INTEGER is&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;deferred&#xA;</xsl:text>
		<xsl:text>&#x9;&#x9;end&#xA;&#xA;</xsl:text>
	</xsl:for-each>

end -- <xsl:value-of select="$prefix_upper"/>_XML_DOCUMENT

</xsl:template>
 

<xsl:template match="rng:element" mode="element_name">

	<!-- Name of a feature that adds an element to the document -->

	<xsl:choose>
		<xsl:when test="descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name)]">
			<xsl:text>start_</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>add_</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:value-of select="../@name" />
	<xsl:text>_element</xsl:text>
</xsl:template>

<xsl:template match="rng:ref" mode="build_feature_variables">

	<!-- The feature parameters for a feature that adds an element to the document -->

	<xsl:variable name="attribute" select="key ('attributes', @name)" />
	<xsl:if test="$attribute">
		<xsl:variable name="includes_elements" select="key ('elements', @name)/descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name)]" />
		<xsl:variable name="current_ref" select="@name" />
		<xsl:choose>
			<xsl:when test="ancestor::rng:choice/rng:ref[1]/@name = $current_ref">
				<xsl:apply-templates select="." mode="choice_name" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="name_type"/>
				<xsl:text>; </xsl:text>
				<xsl:apply-templates select="." mode="choice_value" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="value_type"/>
			</xsl:when>
			<xsl:when test="ancestor::rng:choice"></xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="." mode="attribute_value_variable" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="value_type"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="(not (ancestor::rng:choice)) or (ancestor::rng:choice/rng:ref[1]/@name = $current_ref)">
			<xsl:text>; </xsl:text>
		</xsl:if>
	</xsl:if>
</xsl:template>



<xsl:template match="rng:element" mode="fragment_when_list">

	<!-- 	Create a when statement that identifies call {XML_CONTENT_SCHEMA}.is_valid_fragment
		by element_code -->
		
	<xsl:variable name="element_name" select="../@name" />
	<xsl:text>				when </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_element_code then&#xA;</xsl:text>
	<xsl:text>					Result := </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_content_validity.is_valid_content_fragment (the_fragment)&#xA;</xsl:text>
</xsl:template>

<xsl:output method="text" />
</xsl:transform>