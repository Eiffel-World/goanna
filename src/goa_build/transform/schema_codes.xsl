<?xml version="1.0"?> 
<!--
     	description: "Output An Eiffel File with Codes and Facilities Representing the Elements/Attributes in a Relax NG Schema "
	author: "Neal L Lester <neal@3dsafety.com>"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "Copyright (c) 2004 Neal L Lester"
	license:   "Eiffel Forum License V2.0 (http://www.opensource.org/licenses/ver2_eiffel.php)"

-->
<xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
  xmlns:rng="http://relaxng.org/ns/structure/1.0"
  exclude-result-prefixes="rng"
  >
  <xsl:include href="common.xsl" />
  <xsl:template match="/rng:grammar">
indexing

	description: "Codes and constants representing elements/attributes of the xmlns:<xsl:value-of select="$prefix_lower"/> schema"
	author: "<xsl:value-of select="$author" />"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "<xsl:value-of select="$copyright" />"
	license: "<xsl:value-of select="$license" />"
	
-- DO NOT EDIT THIS FILE
-- This file was generated by schema_codes.xsl
-- Any changes made to this file will be overwritten the 
-- next time the XSL Transformation is run.

class
	<xsl:value-of select="$prefix_upper" />_SCHEMA_CODES

feature -- Element Tags

	<xsl:for-each select="//rng:element" >
		<xsl:apply-templates select="." mode="element_tag_constant" />
		<xsl:text>: STRING is "</xsl:text>
		<xsl:value-of select="lower-case(@name)" />
		<xsl:text>"&#xA;&#x9;</xsl:text>
	</xsl:for-each>	
	
feature -- Attribute Names

	<xsl:for-each select="//rng:attribute" >
		<xsl:variable name="fixed_tag" select="translate(@name, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ:-', 'abcdefghijklmnopqrstuvwxyz__')" />
		<xsl:apply-templates select="." mode="attribute_name_constant" />
		<xsl:text>: STRING is "</xsl:text>
		<xsl:value-of select="$fixed_tag" />
		<xsl:text>"&#xA;&#x9;</xsl:text>
	</xsl:for-each>	

feature -- Codes

	<xsl:for-each select="//rng:attribute" >
		<xsl:apply-templates select="." mode="attribute_code" />
		<xsl:choose>
			<xsl:when test="position () mod 4 != 0">
				<xsl:text>, </xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>,&#xA;&#x9;</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:for-each>
		
	<xsl:for-each select="//rng:element" >

		<xsl:apply-templates select="." mode="element_code" />
		<xsl:choose>
			<xsl:when test="position() != last() and position () mod 4 != 0">
				<xsl:text>, </xsl:text>
			</xsl:when>
			<xsl:when test="position() != last() and position () mod 4 = 0">
				<xsl:text>,&#xA;&#x9;</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>, xml_text_code, xml_null_code: INTEGER is Unique</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:for-each>	

feature -- Valid Attribute Values
	
	is_valid_attribute_value (attribute_name_code: INTEGER; attribute_value: STRING): BOOLEAN is
			-- is attribute_value valid for athe attribute given by attribute_name_code
		do
<xsl:variable name="attributes_requiring_validation" select="//rng:attribute[descendant::rng:value or descendant::rng:data]" />
	<xsl:choose>
		<xsl:when test="$attributes_requiring_validation">
			<xsl:text>			Result :=  True&#xA;</xsl:text>
			<xsl:text>			inspect attribute_name_code&#xA;</xsl:text>
			<xsl:for-each select="$attributes_requiring_validation">
				<xsl:apply-templates select="." mode="attribute_validation"/>
			</xsl:for-each>
			<xsl:text>				else&#xA;</xsl:text>
			<xsl:text>					Result := True&#xA;</xsl:text>
			<xsl:text>			end&#xA;</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>			Result := True&#xA;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>		end&#xA;&#xA;</xsl:text>

feature {NONE} -- Implementation
	
	<xsl:for-each select="//rng:attribute[descendant::rng:value]">
		<xsl:text>	valid_</xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>_attribute_values: DS_LINKED_LIST [STRING] is&#xA;</xsl:text>
		<xsl:text>			-- Valid values for the </xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>attribute&#xA;</xsl:text>
		<xsl:text>		once&#xA;</xsl:text>
		<xsl:text>			create Result.make_equal&#xA;</xsl:text>
		<xsl:apply-templates select="rng:value" mode="enumeration" />
		<xsl:apply-templates select="rng:choice/rng:value" mode="enumeration" />
		<xsl:text>		end&#xA;&#xA;</xsl:text>
	</xsl:for-each>

	element_code_by_tag: DS_HASH_TABLE [INTEGER, STRING] is
			-- Element codes, keyed by element tag
		once
			create Result.make_equal (30)
<xsl:apply-templates select="//rng:element" mode="hash_table_by_tag" />
<xsl:text>		end</xsl:text>
		
	element_tag_by_code: DS_HASH_TABLE [STRING, INTEGER] is
			-- Element tags, keyed by element code
		once
			create Result.make_equal (30)
<xsl:apply-templates select="//rng:element" mode="hash_table_by_code" />
<xsl:text>		end</xsl:text>
		
	attribute_code_by_name: DS_HASH_TABLE [INTEGER, STRING] is
			-- Attribute codes, keyed by attribute name
		once
			create Result.make_equal (30)
<xsl:apply-templates select="//rng:attribute" mode="hash_table_by_name" />
<xsl:text>		end</xsl:text>
		
	attribute_name_by_code: DS_HASH_TABLE [STRING, INTEGER] is
			-- Attribute names, keyed by attribute code
		once
			create Result.make_equal (30)
<xsl:apply-templates select="//rng:attribute" mode="hash_table_by_code" />
<xsl:text>		end</xsl:text>

end -- <xsl:value-of select="$prefix_upper"/>_SCHEMA_CODES

 </xsl:template>

 <xsl:template match="rng:value" mode="enumeration">
 
 	<!-- 	Add members of DS_LINKED_LIST representing valid values in an 
 		attribute value enumeration -->
 
	<xsl:text>			Result.put_last ("</xsl:text>
	<xsl:value-of select="." />
	<xsl:text>")&#xA;</xsl:text>
</xsl:template>
			
<xsl:template match="rng:attribute" mode="attribute_validation">

	<!--	Build attribute value validation -->

	<xsl:text>				when </xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>_attribute_code then&#xA;</xsl:text>
	<xsl:if test="descendant::rng:value">
		<xsl:text>					Result := Result and valid_</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>_attribute_values.has (attribute_value)&#xA;</xsl:text>
	</xsl:if>
	<xsl:if test="descendant::rng:data/@type = 'nonNegativeInteger'">
		<xsl:text>					Result := Result and attribute_value.is_integer and then attribute_value.to_integer >= 0&#xA;</xsl:text>
	</xsl:if>
	
	<!--	Add additional validity checks here.  They should be of the form
		Result := Result and additional_validity_check because a single
		value can have multiple validity constraints -->
	
</xsl:template>

<xsl:template match="rng:element" mode="hash_table_by_tag">

	<!-- 	Add entries to the hash table that references
		element codes keyed by element tag -->
		
 	<xsl:text>			Result.force (</xsl:text>
 	<xsl:apply-templates select="." mode="element_code" />
 	<xsl:text>, </xsl:text>
 	<xsl:apply-templates select="." mode="element_tag_constant" />
 	<xsl:text>)&#xA;</xsl:text>
 </xsl:template>

<xsl:template match="rng:element" mode="hash_table_by_code">

	<!--	Add entries to the hash table that references
		element tags keyed by element code -->

 	<xsl:text>			Result.force (</xsl:text>
 	<xsl:apply-templates select="." mode="element_tag_constant" />
 	<xsl:text>, </xsl:text>
 	<xsl:apply-templates select="." mode="element_code" />
 	<xsl:text>)&#xA;</xsl:text>
 </xsl:template>

<xsl:template match="rng:attribute" mode="hash_table_by_name">

	<!--	Add entries to the hash table that references
		attribute codes keyed by attribute name -->
		
	<xsl:text>			Result.force (</xsl:text>
	<xsl:apply-templates select="." mode="attribute_code" />
	<xsl:text>, </xsl:text>
	<xsl:apply-templates select="." mode="attribute_name_constant" />
	<xsl:text>)&#xA;</xsl:text>
</xsl:template>

<xsl:template match="rng:attribute" mode="hash_table_by_code">

	<!--	Add entries to the hash table that references
		attribute names keyed by attribute name -->

 	<xsl:text>			Result.force (</xsl:text>
 	<xsl:apply-templates select="." mode="attribute_name_constant" />
 	<xsl:text>, </xsl:text>
 	<xsl:apply-templates select="." mode="attribute_code" />
 	<xsl:text>)&#xA;</xsl:text>
</xsl:template>

<xsl:output method="text" />
 
</xsl:transform>