<?xml version="1.0"?> 
<!--
     	description: "Create an Eiffel Class that represents (can write) an XML document conforming with a Relax NG Schema"
	author: "Neal L Lester <neal@3dsafety.com>"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "Copyright (c) 2004 Neal L Lester"
	license:   "Eiffel Forum License V2.0 (http://www.opensource.org/licenses/ver2_eiffel.php)"

DESCRIPTION

The four files common.xsl, schema_codes.xsl, deferred_xml_writer, 
and validating_xml_wrter.xsl are xslt transforms that generate
eiffel classes from a Relax NG grammar.  

http://www.oasis-open.org/committees/relax-ng/spec-20011203.html

schema_codes.xsl creates a class that includes integer
codes and string constants representing the elements and attributes
defined in the schema.

deferred_xml_writer.xsl creates a deferred class that represents a
schema fragment intended for inclusion in another schema.  This allows
eiffel to see documents containing the included schema as distinct
types.

common.xsl contains some templates that are common to the various
transforms.

validating_xml_writer.xsl outputs an eiffel class that includes features
for creating and populating an xml document conforming with the
Relax NG schema.  The validity rules defined by the Relax NG grammar
are embedded as preconditions in the eiffel class.

See test/sample.rnc for an example schema that passes all unit tests.

See test/generate_classes.sh for an example of how to use the
transforms on Linux using the Saxon xslt processor.  

Use the parameters author, copyright, and license to populate the
corresponding indexing clauses in the generated Eiffel classes.

KNOWN LIMITATIONS

1) The Relax NG grammar used as input to the stylesheet may include
   elements from only one namespace, and that namespace must be named
   first in the grammar element.
2) The transforms assume that the xslt processor will return namespace
   prefixes in the order declared in the grammar element (Saxon does).
   If the class and feature names don't match the grammar namespace
   prefix, then pass in the prefix as a parameter
   (prefix=namespace-prefix)   
3) A mandatory element following an optional choice element of the
   same name may be incorrectly rejected by the class (e.g. an element
   containing elements { (name1 | name2)*, name1 } the element will be incorrectly
   rejected as invalid if it contains only one name1 element.
4) xsd:nonNegativeInteger is the only data type supported (it should be easy
   to add more).
5) Nested element choices e.g. { (element1, element2) | element3 } are
   not supported.
6) When combining grammars, only the combine="choice" option ( |= in compact
   syntax notation) is supported.  The element in the included file
   must be a choice element.  Note that there are no automated checks to ensure
   the input files comform with this requirement.
7) Does not (currently) support mixing namespaces that contain elements
   with the same name.
	
-->
<xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
  xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:imp="http://www.sourceforge.net/projects/goanna/imported_grammars"
  exclude-result-prefixes="rng"
>
	<xsl:variable name="transform_file_name" as="xs:string" select="concat ($prefix, '.xsl')" />
	<xsl:variable name="schema_file_name" as="xs:string" select="concat ($prefix, '.frng')" />
	<xsl:include href="common.xsl" />
	<xsl:output method="text" />

<xsl:template match="/rng:grammar">
<!-- I don't think these are needed anymore

	xsl:variable name="name" as="xs:string" select="@name"/
 	xsl:variable name="element" as="xs:node()*" select="key ('elements', $name)" /
 	xsl:variable name="last_ref" select="$element/descendant::rng:ref[position () = last()]" /
 	xsl:variable name="includes_elements" select="$element/descendant::rng:ref[key ('elements', @name)]" /
 	xsl:variable name="open_ended" select="$last_ref[ancestor::rng:oneOrMore or ancestor::rng:zeroOrMore]" /
	xsl:variable name="include_names" select ="//rng:include/@href" />

-->
indexing

	description: "An XML Document conforming with the xmlns:<xsl:value-of select="$prefix_lower"/> schema"
	author: "<xsl:value-of select="$author" />"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "<xsl:value-of select="$copyright" />"
	license: "<xsl:value-of select="$license" />"
	
-- DO NOT EDIT THIS FILE
-- This file was generated by validating_xml_writer.xsl
-- Any changes made to this file will be overwritten the 
-- next time the XSL Transformation is run.

class
	<xsl:value-of select="$prefix_upper" />_XML_DOCUMENT
	
inherit
	<xsl:value-of select="$prefix_upper" />_SCHEMA_CODES
	<xsl:value-of select="$prefix_upper" />_ATTRIBUTE_VALUES
	GOA_XML_DOCUMENT
	<xsl:apply-templates select="//rng:include" />	
creation

	make_iso_8859_1_encoded, make_utf8_encoded

feature -- Adding Elements

<xsl:for-each select="//rng:element">
	<xsl:apply-templates select="." mode="element_features">
		<xsl:with-param name="is_deferred" select="'no'" />
		<xsl:with-param name="include_dbc">
			<xsl:variable name="current_name" as="xs:string" select="@name" />
			<xsl:choose>
				<xsl:when test="document ($imported_file_name)//imp:ref[@name=$current_name]">no</xsl:when>
				<xsl:otherwise>yes</xsl:otherwise>
			</xsl:choose>
		</xsl:with-param>
	</xsl:apply-templates>

	
</xsl:for-each>

feature -- Element Validity
		
	is_valid_element_content_fragment (the_element_code: INTEGER; the_fragment: ARRAY [INTEGER]): BOOLEAN is
			-- Is the_fragment a valid valid element/text sequence in element given by the_element_code
		do
			inspect the_element_code
<xsl:apply-templates select="//rng:element[descendant::rng:ref[key ('elements', @name)]]" mode="fragment_when_list" />
<xsl:text>			else</xsl:text>
				Result := False
			end
		end

	is_valid_element_content (the_element_code: INTEGER; the_content: ARRAY [INTEGER]): BOOLEAN is
			-- Is the_content a valid complete and valid element/text sequence in element given by the_element_code
		do
			inspect the_element_code
<xsl:apply-templates select="//rng:element[descendant::rng:ref[key ('elements', @name)]]" mode="content_when_list" />
<xsl:text>			else</xsl:text>
				Result := False
			end
		end

feature -- {NONE} -- Element Content Validity

	<xsl:apply-templates select="//rng:element[descendant::rng:ref[key ('elements', @name)]]" mode="content_validity" />

feature {NONE} -- Transformation

	transform_file_name: STRING is
			-- Name of file containing the XSLT transform to produce an HTML version of this document
		once
			Result := configuration.xslt_directory + "<xsl:value-of select="$transform_file_name" />"
		end

	schema_file_name: STRING is
			-- Name of the file containing the Relax NG Schema for this document
		once
			Result := configuration.xslt_directory + "<xsl:value-of select="$schema_file_name" />"
		end
				
end -- <xsl:value-of select="$prefix_upper"/>_XML_DOCUMENT

</xsl:template> 

<xsl:template match="rng:element" mode="element_name">

	<!-- Name of a feature that adds an element to the document -->

	<xsl:choose>
		<xsl:when test="descendant::rng:ref[key ('elements', @name)]">
			<xsl:text>start_</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>add_</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:value-of select="../@name" />
	<xsl:text>_element</xsl:text>
</xsl:template>

<xsl:template match="rng:ref" mode="build_feature_variables">

	<!-- The feature parameters for a feature that adds an element to the document -->

	<xsl:variable name="attribute" as="node()?" select="key ('attributes', @name)" />
	<xsl:if test="$attribute">
		<xsl:variable name="includes_elements" as="xs:boolean" select="count (key ('elements', @name)/descendant::rng:ref[key ('elements', @name)]) > 0" />
		<xsl:variable name="current_ref" as="node()?" select="@name" />
		<xsl:choose>
			<xsl:when test="ancestor::rng:choice/rng:ref[1]/@name = $current_ref">
				<xsl:apply-templates select="." mode="choice_name" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="name_type"/>
				<xsl:text>; </xsl:text>
				<xsl:apply-templates select="." mode="choice_value" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="value_type"/>
			</xsl:when>
			<xsl:when test="ancestor::rng:choice"></xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="." mode="attribute_value_variable" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="value_type"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="(not (ancestor::rng:choice)) or (ancestor::rng:choice/rng:ref[1]/@name = $current_ref)">
			<xsl:text>; </xsl:text>
		</xsl:if>
	</xsl:if>
</xsl:template>

<xsl:template match="rng:element" mode="fragment_when_list">

	<!-- 	Create a when statement that identifies call {GOA_XML_CONTENT_SCHEMA}.is_valid_fragment
		by element_code -->
		
	<xsl:variable name="element_name" as="xs:string" select="../@name" />
	<xsl:text>				when </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_element_code then&#xA;</xsl:text>
	<xsl:text>					Result := </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_content_validity.is_valid_content_fragment (the_fragment)&#xA;</xsl:text>
</xsl:template>

<xsl:template match="rng:element" mode="content_when_list">

	<!-- 	Create a when statement that identifies call {GOA_XML_CONTENT_SCHEMA}.is_valid_content
		by element_code -->
		
	<xsl:variable name="element_name" as="xs:string" select="../@name" />
	<xsl:text>				when </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_element_code then&#xA;</xsl:text>
	<xsl:text>					Result := </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_content_validity.is_valid_content (the_content)&#xA;</xsl:text>
</xsl:template>

<xsl:template match="rng:ref" mode="valid_elements_when_list">

	<!-- Not Used; Will I need the test later? -->
	
	<xsl:variable name="current_ref_name" as="xs:string" select="@name"/>
	<xsl:choose>
		<xsl:when test="preceding-sibling::rng:ref[@name = $current_ref_name]" />
		<xsl:otherwise>
			<xsl:text>&#x9;&#x9;&#x9;&#x9;when </xsl:text><xsl:value-of select="@name" /><xsl:text>_element_code then&#xA;</xsl:text>
			<xsl:text>Result := True</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="rng:element" mode="content_validity">

	<!-- 	Create an XML_CONTENT_SCHEMA class (named element_name_content_validity) 
		defining valid elements and-or text that may be contained within
		the element -->
		
	<xsl:variable name="element_name" as="xs:string" select="../@name" />
	<xsl:value-of select="$element_name" />
	<xsl:text>_content_validity: GOA_XML_ELEMENT_SCHEMA is&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;&#x9;-- Schema representing valid contents of a(n) </xsl:text><xsl:value-of select="$element_name" /><xsl:text> element&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;once&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;&#x9;create Result.make&#xA;</xsl:text>
	<xsl:for-each select="descendant::*">
		<xsl:if test="count (key ('elements', @name)) > 0 or local-name () eq 'text' or (local-name () eq 'choice') and count (descendant::rng:ref[key ('elements', @name)]) > 0">
			<xsl:variable name="this_node" as="node()" select="." />
			<xsl:variable name="is_text" as="xs:boolean" select="local-name () eq 'text'" />
			<xsl:variable name="is_in_a_choice" as="xs:boolean" select="count (ancestor::rng:choice) > 0" />
			<xsl:variable name="is_a_choice" as="xs:boolean" select="local-name () eq 'choice'" />
			<xsl:variable name="is_multiple" as="xs:boolean" select="count (ancestor::rng:zeroOrMore) > 0 or count (ancestor::rng:oneOrMore) > 0" />
			<xsl:variable name="is_required" as="xs:boolean" select="not ((count (ancestor::rng:optional) > 0) or (count(ancestor::rng:zeroOrMore)) > 0)" />
			<xsl:variable name="elements_argument_components" as="xs:string*">
				<xsl:choose>
					<xsl:when test="$is_a_choice">
						<xsl:apply-templates select="." mode="contents_as_element_code_array" />
					</xsl:when>
					<xsl:when test="$is_in_a_choice"></xsl:when>
					<xsl:when test="key ('elements', @name)">
						<xsl:text>&lt;&lt;</xsl:text><xsl:value-of select="@name" /><xsl:text>_element_code&gt;&gt;</xsl:text>
					</xsl:when>
					<xsl:when test="$is_text">
						<xsl:text>&lt;&lt;xml_text_code&gt;&gt;</xsl:text>
					</xsl:when>
					<xsl:otherwise></xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="elements_argument" as="xs:string?" select="string-join ($elements_argument_components, '')" />
			<xsl:if test="string-length ($elements_argument) > 0" >
				<xsl:choose>
					<xsl:when test="ancestor::rng:zeroOrMore">
						<xsl:text>&#x9;&#x9;&#x9;Result.add_zero_or_more_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::rng:oneOrMore">
						<xsl:text>&#x9;&#x9;&#x9;Result.add_one_or_more_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::rng:optional">
						<xsl:text>&#x9;&#x9;&#x9;Result.add_optional_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text></xsl:when>
					<xsl:otherwise>
						<xsl:text>&#x9;&#x9;&#x9;Result.add_required_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
		</xsl:if>
	</xsl:for-each>
	<xsl:text>&#x9;&#x9;end&#xA;&#xA;&#x9;</xsl:text>
</xsl:template>
		

</xsl:transform>