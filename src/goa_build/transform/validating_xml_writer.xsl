<?xml version="1.0"?> 
<!--
     	description: "Create an Eiffel Class that represents (can write) an XML document conforming with a Relax NG Schema"
	author: "Neal L Lester <neal@3dsafety.com>"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "Copyright (c) 2004 Neal L Lester"
	license:   "Eiffel Forum License V2.0 (http://www.opensource.org/licenses/ver2_eiffel.php)"

-->
<xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
  xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:imp="http://www.sourceforge.net/projects/goanna/imported_grammars"
  exclude-result-prefixes="rng"
>
	<xsl:variable name="transform_file_name" as="xs:string" select="concat ($prefix, '.xsl')" />
	<xsl:variable name="schema_file_name" as="xs:string" select="concat ($prefix, '.frng')" />
	<xsl:include href="common.xsl" />
	<xsl:output method="text" />

<xsl:template match="/rng:grammar">
<!-- I don't think these are needed anymore

	xsl:variable name="name" as="xs:string" select="@name"/
 	xsl:variable name="element" as="xs:node()*" select="key ('elements', $name)" /
 	xsl:variable name="last_ref" select="$element/descendant::rng:ref[position () = last()]" /
 	xsl:variable name="includes_elements" select="$element/descendant::rng:ref[key ('elements', @name)]" /
 	xsl:variable name="open_ended" select="$last_ref[ancestor::rng:oneOrMore or ancestor::rng:zeroOrMore]" /
	xsl:variable name="include_names" select ="//rng:include/@href" />

-->
indexing

	description: "An XML Document conforming with the xmlns:<xsl:value-of select="$prefix_lower"/> schema"
	author: "<xsl:value-of select="$author" />"
	date: "$Date$"
	revision: "$Revision$"
	copyright: "<xsl:value-of select="$copyright" />"
	license: "<xsl:value-of select="$license" />"
	
-- DO NOT EDIT THIS FILE
-- This file was generated by validating_xml_writer.xsl
-- Any changes made to this file will be overwritten the 
-- next time the XSL Transformation is run.

class
	<xsl:value-of select="$prefix_upper" />_XML_DOCUMENT
	
inherit
	<xsl:value-of select="$prefix_upper" />_SCHEMA_CODES
	<xsl:value-of select="$prefix_upper" />_ATTRIBUTE_VALUES
	GOA_XML_DOCUMENT
	<xsl:apply-templates select="//rng:include" />	
creation

	make_iso_8859_1_encoded, make_utf8_encoded

feature -- Adding Elements

<xsl:for-each select="//rng:element">
	<xsl:apply-templates select="." mode="element_features">
		<xsl:with-param name="is_deferred" select="'no'" />
		<xsl:with-param name="include_dbc">
			<xsl:variable name="current_name" as="xs:string" select="@name" />
			<xsl:choose>
				<xsl:when test="document ($imported_file_name)//imp:ref[@name=$current_name]">no</xsl:when>
				<xsl:otherwise>yes</xsl:otherwise>
			</xsl:choose>
		</xsl:with-param>
	</xsl:apply-templates>

	
</xsl:for-each>

feature -- Element Validity
		
	is_valid_element_content_fragment (the_element_code: INTEGER; the_fragment: ARRAY [INTEGER]): BOOLEAN is
			-- Is the_fragment a valid valid element/text sequence in element given by the_element_code
		do
			inspect the_element_code
<xsl:apply-templates select="//rng:element[descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name)]]" mode="fragment_when_list" />
			else
				Result := False
			end
		end

	is_valid_element_content (the_element_code: INTEGER; the_content: ARRAY [INTEGER]): BOOLEAN is
			-- Is the_content a valid complete and valid element/text sequence in element given by the_element_code
		do
			inspect the_element_code
<xsl:apply-templates select="//rng:element[descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name)]]" mode="content_when_list" />
			else
				Result := False
			end
		end

feature -- {NONE} -- Element Content Validity

	<xsl:apply-templates select="//rng:element[descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name)]]" mode="content_validity" />
	<xsl:apply-templates select="$all_element_collections" mode="content_validity" />
	
feature {NONE} -- Transformation

	transform_file_name: STRING is
			-- Name of file containing the XSLT transform to produce an HTML version of this document
		once
			Result := configuration.xslt_directory + "<xsl:value-of select="$transform_file_name" />"
		end

	schema_file_name: STRING is
			-- Name of the file containing the Relax NG Schema for this document
		once
			Result := configuration.xslt_directory + "<xsl:value-of select="$schema_file_name" />"
		end
				
end -- <xsl:value-of select="$prefix_upper"/>_XML_DOCUMENT

</xsl:template> 







<xsl:template match="rng:ref" mode="build_feature_variables">

	<!-- The feature parameters for a feature that adds an element to the document -->

	<xsl:variable name="attribute" as="node()?" select="key ('attributes', @name)" />
	<xsl:if test="$attribute">
		<xsl:variable name="includes_elements" as="xs:boolean" select="count (key ('elements', @name)/descendant::rng:ref[key ('elements', @name) | key ('element_collections', @name) ]) > 0" />
		<xsl:variable name="current_ref" as="node()?" select="@name" />
		<xsl:choose>
			<xsl:when test="ancestor::rng:choice/rng:ref[1]/@name = $current_ref">
				<xsl:apply-templates select="." mode="choice_name" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="name_type"/>
				<xsl:text>; </xsl:text>
				<xsl:apply-templates select="." mode="choice_value" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="value_type"/>
			</xsl:when>
			<xsl:when test="ancestor::rng:choice"></xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="." mode="attribute_value_variable" />
				<xsl:text>: </xsl:text>
				<xsl:apply-templates select="." mode="value_type"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="(not (ancestor::rng:choice)) or (ancestor::rng:choice/rng:ref[1]/@name = $current_ref)">
			<xsl:text>; </xsl:text>
		</xsl:if>
	</xsl:if>
</xsl:template>

<xsl:template match="rng:element" mode="fragment_when_list">

	<!-- 	Create a when statement that identifies call {GOA_XML_CONTENT_SCHEMA}.is_valid_fragment
		by element_code -->
		
	<xsl:variable name="element_name" as="xs:string" select="../@name" />
	<xsl:text>				when </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_element_code then&#xA;</xsl:text>
	<xsl:text>					Result := </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_content_validity.is_valid_content_fragment (the_fragment)&#xA;</xsl:text>
</xsl:template>

<xsl:template match="rng:element" mode="content_when_list">

	<!-- 	Create a when statement that identifies call {GOA_XML_CONTENT_SCHEMA}.is_valid_content
		by element_code -->
		
	<xsl:variable name="element_name" as="xs:string" select="../@name" />
	<xsl:text>				when </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_element_code then&#xA;</xsl:text>
	<xsl:text>					Result := </xsl:text><xsl:value-of select="$element_name" /><xsl:text>_content_validity.is_valid_content (the_content)&#xA;</xsl:text>
</xsl:template>

<xsl:template match="rng:ref" mode="valid_elements_when_list">

	<!-- Not Used; Will I need the test later? -->
	
	<xsl:variable name="current_ref_name" as="xs:string" select="@name"/>
	<xsl:choose>
		<xsl:when test="preceding-sibling::rng:ref[@name = $current_ref_name]" />
		<xsl:otherwise>
			<xsl:text>&#x9;&#x9;&#x9;&#x9;when </xsl:text><xsl:value-of select="@name" /><xsl:text>_element_code then&#xA;</xsl:text>
			<xsl:text>Result := True</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="rng:element" mode="content_validity">
	
	<!-- 	Create an XML_CONTENT_SCHEMA class (named element_name_content_validity) 
		defining valid elements and-or text that may be contained within
		the element -->
	
	<xsl:variable name="element_name" as="xs:string" select="../@name" />
	<xsl:value-of select="$element_name" />
	<xsl:text>_content_validity: GOA_XML_ELEMENT_SCHEMA is&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;&#x9;-- Schema representing valid contents of a(n) </xsl:text><xsl:value-of select="$element_name" /><xsl:text> element&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;once&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;&#x9;create Result.make (&#xA;</xsl:text>
	
	<xsl:apply-templates select="." mode="content_validity_output" />
	
	<xsl:text>&#xA;&#x9;&#x9;&#x9;)&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;end&#xA;&#xA;&#x9;</xsl:text>
</xsl:template>


<xsl:template match="rng:define" mode="content_validity">
	
	<!-- 	Create an GOA_XML_DEERRED_SCHEMA_ELEMENT class (named 'collection_name'_collection) 
		defining valid elements and-or text that may be contained within
		the element -->
	
	<xsl:variable name="collection_name" as="xs:string" select="@name" />
	<xsl:value-of select="$collection_name" />
	<xsl:text>_collection: GOA_XML_DEERRED_SCHEMA_ELEMENT is&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;&#x9;-- Schema representing valid contents of a(n) </xsl:text><xsl:value-of select="$collection_name" /><xsl:text> collection&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;do&#xA;</xsl:text>
	<xsl:text>&#x9;&#x9;&#x9;Result :=&#xA;</xsl:text>
	
	<xsl:apply-templates select="." mode="content_validity_output" />
	
	<xsl:text>&#xA;&#x9;&#x9;end&#xA;&#xA;&#x9;</xsl:text>
</xsl:template>


<xsl:template match="*" mode="content_validity_output">

	<!-- all children which are or contain  'element_refs', 'list_refs' or 'text'-->
	<xsl:variable name="all_children" as="node()*" select="child::*" />
	<xsl:variable name="children" as="node()*" select="$all_children[descendant-or-self::*[key ('elements', @name) | key('element_collections', @name) | self::rng:text]]" />
	
	<!-- all siblings which are or contain  'element_refs', 'element_collection_refs' or 'text'-->
	<xsl:variable name="all_siblings" as="node()*" select="parent::*/*" />
	<xsl:variable name="siblings" as="node()*" select="$all_siblings[descendant-or-self::*[key ('elements', @name) | key('element_collections', @name) | self::rng:text]]" />
	
	<!-- variables which give informations about the parents -->
	<xsl:variable name="is_in_optional" as="xs:boolean" select="count(parent::rng:optional) > 0" />
	<xsl:variable name="is_in_zero_or_more" as="xs:boolean" select="count(parent::rng:zeroOrMore) > 0" />
	<xsl:variable name="is_in_one_or_more" as="xs:boolean" select="count(parent::rng:oneOrMore) > 0" />
	
	<!-- DEBUG  -->
	
	
	
<!--
	
	<xsl:text> local-name: </xsl:text><xsl:value-of select="local-name ()" />
	<xsl:if test="@name">   @name: <xsl:value-of select="@name" /></xsl:if>
	<xsl:text>&#xA;</xsl:text>
	
	<xsl:text> all_children: &#xA;</xsl:text>
	<xsl:for-each select="$all_children">
		<xsl:text>&#x9; local-name: </xsl:text><xsl:value-of select="local-name ()" />
		<xsl:if test="@name">   @name: <xsl:value-of select="@name" /></xsl:if>
		<xsl:text>&#xA;</xsl:text>
	</xsl:for-each>
	<xsl:text> children: &#xA;</xsl:text>
	<xsl:for-each select="$children">
		<xsl:text>&#x9; local-name: </xsl:text><xsl:value-of select="local-name ()" />
		<xsl:if test="@name">   @name: <xsl:value-of select="@name" /></xsl:if>
		<xsl:text>&#xA;</xsl:text>
	</xsl:for-each>
	<xsl:text> all_sibling &#xA;</xsl:text>
	<xsl:for-each select="$all_siblings">
		<xsl:text>&#x9; local-name: </xsl:text><xsl:value-of select="local-name ()" />
		<xsl:if test="@name">   @name: <xsl:value-of select="@name" /></xsl:if>
		<xsl:text>&#xA;</xsl:text>
	</xsl:for-each>
	<xsl:text> sibling &#xA;</xsl:text>
	<xsl:for-each select="$siblings">
		<xsl:text>&#x9; local-name: </xsl:text><xsl:value-of select="local-name ()" />
		<xsl:if test="@name">   @name: <xsl:value-of select="@name" /></xsl:if>
		<xsl:text>&#xA;</xsl:text>
	</xsl:for-each>
	<xsl:text> is_in_optional: </xsl:text><xsl:value-of select="$is_in_optional" /><xsl:text>&#xA;</xsl:text>
	<xsl:text> is_in_zero_or_more: </xsl:text><xsl:value-of select="$is_in_zero_or_more" /><xsl:text>&#xA;</xsl:text>
	<xsl:text> is_in_one_or_more: </xsl:text><xsl:value-of select="$is_in_one_or_more" /><xsl:text>&#xA;&#xA;</xsl:text>
	
	
	
	<xsl:for-each select="//rng:define[child::rng:choice]">
		<xsl:text>&#x9; local-name: </xsl:text><xsl:value-of select="local-name ()" />
		<xsl:if test="@name">   @name: <xsl:value-of select="@name" /></xsl:if>
		<xsl:text>&#xA;</xsl:text>
	</xsl:for-each>
	
	
	 END OF DEBUG -->
	
	
	
	
	<!-- name of the creation procedures -->
	<xsl:variable name="creation_procedure" as="xs:string">
		<xsl:choose>
			<!-- for conjunctions of elments in 'group', 'optional', 'zeroOrMore' or 'oneOrMore' -->
			<xsl:when test="local-name () eq 'group'">
				<xsl:text>make_required</xsl:text>
			</xsl:when>
			<xsl:when test="local-name () eq 'optional'">
				<xsl:text>make_optional</xsl:text>
			</xsl:when>
			<xsl:when test="local-name () eq 'zeroOrMore'">
				<xsl:text>make_zero_or_more</xsl:text>
			</xsl:when>
			<xsl:when test="local-name () eq 'oneOrMore'">
				<xsl:text>make_one_or_more</xsl:text>
			</xsl:when>
			
			<!-- for elements in a collection -->
			<xsl:when test="count ($siblings) > 1">
				<xsl:text>make_required</xsl:text>
			</xsl:when>
			
			<!-- for single elements -->
			<xsl:when test="$is_in_optional">
				<xsl:text>make_optional</xsl:text>
			</xsl:when>
			<xsl:when test="$is_in_zero_or_more">
				<xsl:text>make_zero_or_more</xsl:text>
			</xsl:when>
			<xsl:when test="$is_in_one_or_more">
				<xsl:text>make_one_or_more</xsl:text>
			</xsl:when>
			
			<xsl:otherwise>
				<xsl:text>make_required</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	
	<xsl:choose>
		<xsl:when test="local-name () eq 'text' or local-name () eq 'ref'">
			<xsl:choose>
				<!-- Output for 'text' 'elements' and 'element_collections' -->
				<xsl:when test="local-name () eq 'text'">
					<xsl:text>&#x9;&#x9;&#x9;&#x9;create {GOA_XML_SCHEMA_ELEMENT}.</xsl:text>
					<xsl:value-of select="$creation_procedure" />
					<xsl:text> (xml_text_code)</xsl:text>
				</xsl:when>
				<xsl:when test="count (key ('elements', @name)) > 0">
					<xsl:text>&#x9;&#x9;&#x9;&#x9;create {GOA_XML_SCHEMA_ELEMENT}.</xsl:text>
					<xsl:value-of select="$creation_procedure" />
					<xsl:text> (</xsl:text><xsl:value-of select="@name" /><xsl:text>_element_code)</xsl:text>
				</xsl:when>
				<xsl:when test="count (key ('element_collections', @name)) > 0">
					<xsl:text>&#x9;&#x9;&#x9;&#x9;</xsl:text><xsl:value-of select="@name" /><xsl:text>_collection</xsl:text>
				</xsl:when>
			</xsl:choose>
		</xsl:when>
		
		<xsl:otherwise>
			<!-- we only need to start a collection if this element is a 'choice' a 'group' or contains more than one children -->
			<xsl:variable name="start_collection" as="xs:boolean" select="local-name () eq 'choice' or local-name () eq 'group' or count ($children) > 1" />
			<xsl:variable name="actual_class_name" as="xs:string">
				<xsl:choose>
					<!-- if this is a 'choice' we start a disjunction -->
					<xsl:when test="local-name () eq 'choice'">
						<xsl:text>GOA_XML_SCHEMA_ELEMENT_DISJUNCTION</xsl:text>
					</xsl:when>
					
					<!-- else we start a disjunction -->
					<xsl:otherwise>
						<xsl:text>GOA_XML_SCHEMA_ELEMENT_CONJUNCTION</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			
			<xsl:if test="$start_collection">
				<xsl:text>&#x9;&#x9;&#x9;&#x9;create {</xsl:text><xsl:value-of select="$actual_class_name" /><xsl:text>}.</xsl:text>
				<xsl:value-of select="$creation_procedure" />
				<xsl:text> (&#xA;</xsl:text>
				<xsl:text>&#x9;&#x9;&#x9;&#x9;&lt;&lt;&#xA;</xsl:text>
			</xsl:if>
			
			<!-- in any case we do a recursiv call for each child -->
			<xsl:for-each select="$children">
				<xsl:apply-templates select="." mode="content_validity_output" />
				<xsl:if test="position() != last()"><xsl:text>,</xsl:text></xsl:if>
				<xsl:if test="last() != 1"><xsl:text>&#xA;</xsl:text></xsl:if>
			</xsl:for-each>
			
			<!-- if we started an element we need to close it bevor we leaf the template -->
			<xsl:if test="$start_collection">
				<xsl:text>&#x9;&#x9;&#x9;&#x9;&gt;&gt;)</xsl:text>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>
		

<!-- old implementation: can be deleted once the new one is tested -->
<xsl:template match="rng:element" mode="content_validity_output_old">

	<xsl:param name="precursor" select="'none'" />

	<xsl:variable name="exactly_one_child" as="xs:boolean" select="count(child::*) = 0" />

	<xsl:for-each select="descendant::*">
		<!-- if descendant:     is a ref to an element    or          is a text      or    (    is a choice         and  contains refs to elements )  -->
		<xsl:if test="count (key ('elements', @name)) > 0 or local-name () eq 'text' or ((local-name () eq 'choice') and count (descendant::rng:ref[key ('elements', @name)]) > 0)">
			<xsl:variable name="this_node" as="node()" select="." />
			<xsl:variable name="is_text" as="xs:boolean" select="local-name () eq 'text'" />
			<xsl:variable name="is_in_a_choice" as="xs:boolean" select="count (ancestor::rng:choice) > 0" />
			<xsl:variable name="is_a_choice" as="xs:boolean" select="local-name () eq 'choice'" />
			<xsl:variable name="is_multiple" as="xs:boolean" select="count (ancestor::rng:zeroOrMore) > 0 or count (ancestor::rng:oneOrMore) > 0" />
			<xsl:variable name="is_required" as="xs:boolean" select="not ((count (ancestor::rng:optional) > 0) or (count(ancestor::rng:zeroOrMore)) > 0)" />
			<xsl:variable name="elements_argument_components" as="xs:string*">
				<xsl:choose>
					<xsl:when test="$is_a_choice">
						<xsl:apply-templates select="." mode="contents_as_element_code_array" />
					</xsl:when>
					<xsl:when test="$is_in_a_choice"></xsl:when>
					<xsl:when test="key ('elements', @name)">
						<xsl:text>&lt;&lt;</xsl:text><xsl:value-of select="@name" /><xsl:text>_element_code&gt;&gt;</xsl:text>
					</xsl:when>
					<xsl:when test="$is_text">
						<xsl:text>&lt;&lt;xml_text_code&gt;&gt;</xsl:text>
					</xsl:when>
					<xsl:otherwise></xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="elements_argument" as="xs:string?" select="string-join ($elements_argument_components, '')" />
			<xsl:if test="string-length ($elements_argument) > 0" >
				<xsl:choose>
					<xsl:when test="ancestor::rng:zeroOrMore">
						<xsl:text>&#x9;&#x9;&#x9;Result.add_zero_or_more_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::rng:oneOrMore">
						<xsl:text>&#x9;&#x9;&#x9;Result.add_one_or_more_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::rng:optional">
						<xsl:text>&#x9;&#x9;&#x9;Result.add_optional_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text></xsl:when>
					<xsl:otherwise>
						<xsl:text>&#x9;&#x9;&#x9;Result.add_required_element (</xsl:text><xsl:value-of select="$elements_argument" /><xsl:text>)&#xA;</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
		</xsl:if>
	</xsl:for-each>
</xsl:template>
		

</xsl:transform>